# this file creates and runs an animation visualization grid via a sliding window data processing
# technique. this code only works on smaller datasets (1000 trajectories).

# all imported files / software
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from pymongo import MongoClient
import urllib
import data_process_improved
import graph_data_improved as gdi
from concurrent.futures import ThreadPoolExecutor


# connecting to database
username = urllib.parse.quote_plus('readonly')
password = urllib.parse.quote_plus('mongodb@i24')
client = MongoClient('mongodb://%s:%s@10.80.4.91' % (username, password))
db = client["reconciled"]  # put database name here
col = db["groundtruth_scene_1_130__cajoles"]
# col = db["tm_900_raw_v4.1__1"]

# this is a function that initializes the grid of 5 subplots, and returns the figure as well as
# each of the 5 axes
def make_grid():

    figure = plt.figure()

    plt.rcParams.update({'font.size': 8})
    plt.subplots_adjust(left = 0.125, right = 0.9, bottom = 0.1, top = 0.9, wspace=0.2, hspace=0.5)

    gs = matplotlib.gridspec.GridSpec(nrows=4, ncols=2, height_ratios=[1,4,4,4])

    title = figure.add_subplot(gs[0, 0:2])
    title.set_axis_off()
    title.text(0.47, 0.5, "Plots", fontsize=20, color="#808080")

    # indiv
    i1 = figure.add_subplot(gs[1, 0])
    i2 = figure.add_subplot(gs[1, 1])
    i3 = figure.add_subplot(gs[2, 0])
    i4 = figure.add_subplot(gs[2, 1])
    i5 = figure.add_subplot(gs[3, 0])
    return figure, i1, i2, i3, i4, i5

# this function processes each doc. it calls upon functions within the data_process_improved file
# to calculate the speed, acceleration, lane occupation, and trajectory lengths. it saves the data
# directly to the passed parameter list
def process_doc(doc, speed_lst, accel_lst, lanes_occupied, lengths, vehicle_class):
    data_process_improved.calculate_speed_accel(doc, speed_lst, accel_lst)
    data_process_improved.find_lane_changes(doc, lanes_occupied)
    data_process_improved.calculate_trajectory_lengths(doc, lengths)
    data_process_improved.find_vehicle_class(doc, vehicle_class)

# this is the function that feeds directly into the animation functionality. it clears each axis
# with each new frame and updates the graph in that axis. it takes in a number frame that is
# generated by matplotlib's funcanimation
def update(frame):
    i1.clear()
    speed_lst=big_speed[frame]
    gdi.graph_cur_avg_speed(speed_lst, i1)

    i2.clear()
    accel_lst = big_accel[frame]
    gdi.graph_cur_avg_accel(accel_lst, i2)

    i3.clear()
    lanes_dic = big_lanes[frame]
    gdi.graph_lane_occupation(lanes_dic,i3)

    i4.clear()
    lengths = big_lengths[frame]
    gdi.graph_traj_length(lengths, i4)

    i5.clear()
    vehicle = big_vehicles[frame]
    gdi.graph_vehicle_class(vehicle, i5)

# this is the main function. it finds the min and max of all time stamps within that collection
# of trajectories, and utilizies a sliding window from the start to end w/ increments and window
# sizes. it calls process_doc for each document within each window, and these are saved into the
# global lists big_ATTRIBUTENAME
def main():

    # get the time range of the entire collection
    t_max = col.find().sort("first_timestamp", -1).limit(1)[0]["first_timestamp"]
    t_min = col.find().sort("first_timestamp", 1).limit(1)[0]["first_timestamp"]

    # specify rolling time window and increment
    time_window = 10
    increment = 5
    l, r = t_min, t_min + time_window

    while r < t_max:
        query = {"first_timestamp": {"$gte": l,
                                     "$lt": r}}  # query for all documents whose first_timestamp is within the range [l, r)
        cursor = col.find(query)

        speed_lst = []
        accel_lst = []
        lanes_occupied = {'E1': 0, 'E2': 0, 'E3': 0, 'E4': 0, 'E5': 0, 'E6': 0, 'W1': 0, 'W2': 0,
                          'W3': 0, 'W4': 0, 'W5': 0, 'W6': 0}
        lengths = []
        vehicle_class = {"sedan": 0, "midsize": 0, "pickup": 0, "van": 0, "semi": 0, "truck": 0,
                           "motorcycle": 0}


        # can use threadpool executor or directly w/ cursor

        # while cursor.alive:
        #     doc = cursor.next()
        #     process_doc(doc, speed_lst, accel_lst, lanes_occupied, lengths, vehicle_class)
        with ThreadPoolExecutor(max_workers=8) as executor:
            futures = [executor.submit(process_doc, doc, speed_lst, accel_lst, lanes_occupied, lengths,
                                       vehicle_class) for doc in cursor]

        big_speed.append(speed_lst)
        big_accel.append(accel_lst)
        big_lanes.append(lanes_occupied)
        big_lengths.append(lengths)
        big_vehicles.append(vehicle_class)

        l += increment
        r += increment

big_speed = []
big_accel = []
big_lanes = []
big_lengths = []
big_vehicles = []

figure, i1, i2, i3, i4, i5 = make_grid()

main()
ani = animation.FuncAnimation(fig=figure, func=update, frames=len(big_speed), interval=100,
                              repeat=True)
plt.show()


